# Redis设计与实现

## 第一部分-数据结构与对象

### 1、简单动态字符串(SDS)：

①SDS与普通C字符串的结构区别

1. Redis使用的字符串和传统C语言的字符串不同。C语言使用的是以空字符结尾的字符数组('c' 'h' 'a' 'r' '\0')而Redis使用的是SDS(simpie dynamic string),SDS除了以空字符结尾的字符串还包含两个属性：int len(字符串长度)和int free(字符数组未使用的长度)

   **注**：书中提到'\0'和' ',其中'\0'表示空字符，' '为空格

②SDS的优点

1. len属性可以直接返回数组长度(C字符串需要O(n)时间复杂度的遍历)

1. SDS自带的API可以杜绝缓冲区溢出。如果两个C字符串s1和s2相邻，在对s1进行strcat(拼接)操作时，因为strcat函数默认s1拥有足够的空间会直接在s1后面拼接字符数据进而导致s2字符串被覆盖。但是SDS在进行拼接操作时sdscat函数会先检查SDS空间是否足够，不足则自动扩容后再修改。

2. 减少修改字符串时带来的内存重新分配次数

   - C字符串是N+1长度的字符串(结尾空格)，所以每次增加或者减少字符串是都要扩展或者释放空间。

   - 当SDS的API对SDS进行修改并需要额外分配空间时，都会分配除了必要的额外的未使用空间 	

     - 如果SDS的长度（len属性的值）小于1M，那么SDS额外分配的空间为扩展后长度即假设扩展后长度为13，则总数组长度为 13 + 13 + 1 = 27字节
   - 如果大于1M则，SDS的len会变为30M，每次扩展1M的长度，即buf数组时间长度为30M + 1M + 1byte
   
3. 惰性空间释放 

   - 在执行sdstrim删除字符中的某些字符时并不会立即释放空间，而是当做未使用的长度free在需要时重新使用，当然你也可以使用API手动释放掉这些未使用的内存。

4. 二进制安全 

   - C字符串以'\0'(空字符串结尾为标准)所以除了结尾中间不能有空字符串，不然会被认为是两个字符串所以他只能保存文本数据而不能保存图片、视频、音频、压缩文件等二进制文件，而SDS保存的是二进制数据，其API也是以二进制的方式来处理SDS存放在buf数据里的数据，这样SDS不仅可以保存文本还可以保存任意格式二进制数据(SDS在判断字符串结尾是以len属性为参考，而不是'\0')

5. 可以使用部分C字符串函数 

   - 因为和C字符串相同，SDS也遵循以'\0'结尾，所以可以服用一部分C字符串的函数。

6. 总结(引用书中图片)

![img](https://img-blog.csdnimg.cn/a84349a417344196b72c5b16883ea786.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://img-blog.csdnimg.cn/ebe06173f0914476938ca4a53e3112f7.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 2、链表

1. 链表在redis中的使用非常广泛，因为C语言没有内置链表的数据结构，所以Redis构建了自己的链表（以下只是提到，具体应用后续章节会讲述）
   - 用作列表键
   - 发布与订阅
   - 慢查询
   - 监视器
   - 保存多个客户端的状态信息
   - 构建客户端的输出缓冲区

2. 链表和链表节点的实现

   1. 构成

      - 链表由多个listNode结构组成，每个listNode有三个属性，分别是前置节点prev，后置节点next和节点值value
      - 多个listNode又由list结构来管理(操作)。list包含头结点head、尾节点tail、节点数量len三个属性和节点复制函数dup、节点释放函数free、节点值对比函数match三个函数。
        - dup：复制链表节点所保存的值
        - free：释放链表节点所保存的值
        - match：对比链表节点保存的值和另一个输入值是否相等

      ![image-20231010193152385](/Users/leiyu/Library/Application Support/typora-user-images/image-20231010193152385.png)

3. 链表特性总结

   - 双端：拥有前置节点和后置节点。
   - 无环：头结点的prev和尾节点的next都是指向null
   - 带长度计数器：有len属性，获取链表长度时间复杂度为O(1)
   - 多态：链表节点使用 void* 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点设置类型特定函数，所以链表可以用于保存各种不同类型的值。

4. 总结

   - 链表被广泛用于实现Redis的各种功能,比如列表键、发布与订阅、慢查询、监视 器等。
   - 每个链表节点由一个listNode 结构来表示,每个节点都有一个指向前置节点和后 置节点的指针,所以Redis的链表实现是双端链表。
   - 每个链表使用一个list结构来表示,这个结构带有表头节点指针、表尾节点指针, 以及链表长度等信息。
   - 因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL,所以Redis 的链 表实现是无环链表。
   - 通过为链表设置不同的类型特定函数,Redis的链表可以用于保存各种不同类型的值。

### 3、字典

1. 概览

- 字典,又称为符号表(symbol table)、关联数组(associative array)或映射(map),是 一种用于保存键值对(key-value pair)的抽象数据结构。C语言没有内置的字典数据结构，所以	Redis构建了自己的字典实现。
- 字典用于实现redis的数据库
- 除了用来表示数据库之外,字典还是哈希键的底层实现之一,当一个哈希键包含的键值对比较多,又或者键值对中的元素都是比较长的字符串时,Redis就会使用字典作为哈希键的底层实现。

2. 字典的结构定义

- ![image-20231011095528714](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011095528714.png)
- table是一个数组，里面的每个元素都是一个指针，指向dictEntry结构，每个该结构都存储了一个键值对。
- size记录了hash表的大小
- sizeMask总是等于size - 1，作用是和hash值一起决定了一个键应该被放到table数组的哪个索引上（有点像java的hash算法？）
- used属性记录目前已有节点（键值对）的数量
- ![image-20231011100039799](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011100039799.png)

3. 哈希表的节点dictEntry

- ![image-20231011100121034](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011100121034.png)

- key 属性保存着键值对中的键,而v属性则保存着键值对中的值,其中键值对的值可以是一个指针,或者是一个uint64 t整数,又或者是一个int64_t 整数。

- next 属性是指向另一个哈希表节点的指针,这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突(collision)的问题。

  ![image-20231011102835934](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011102835934.png)

4. 字典的结构

- ![image-20231011103045082](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011103045082.png)

- type属性是指针，指向一个dictType结构，里面有多个用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。

  ![image-20231011112316070](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011112316070.png)

  privdata属性保存了需要传给那些类型特定函数的参数。

  这两个属性配合创建了多态字典。

- ht属性是一个长度固定为2的数组，存储了两个dictht哈希表，一般情况下四、只使用ht[0]这个哈希表，ht[1]这个哈希表只有在对ht[0]进行rehash的时候使用。

- rehashidx记录了rehash目前的进度，如果目前没有在进行rehash，name他的值是-1。

  ![image-20231011112907669](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011112907669.png)

5. 哈希算法(Redis使用的MurmurHash2算法)

6. 使用hashFunction（key）方法算出哈希值（假设为8）

7. 再根据哈希值使用语句hash&dict ->ht[0].sizemask = 8 & 3 = 0（最后结果key的索引值为0 ）

   ![image-20231011113843039](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011113843039.png)

8. 解决哈希冲突

- 当两个或两个以上数量的键被分配到了同一个索引上时我们称这些键发生了哈希冲突(collision)。

- Redis 的哈希表使用链地址法(separate chaining)来解决键冲突,每个哈希表节点都有 一个 next 指针,多个哈希表节点可以用next 指针构成一个单向链表,被分配到同一个索 引上的多个节点可以用这个单向链表连接起来,这就解决了键冲突的问题。

- 如下图，当k2-v2加入字典时，和k1-v1发生了冲突，会将k2放在索引2的头部，排在前面，因为放在表头节点的时间复杂度为O(1)

  ![image-20231011114355185](/Users/leiyu/Library/Application Support/typora-user-images/image-20231011114355185.png)

7. rehash

	1. 为什么要rehash？

    - 为了维持hash表的负载因子在一个合理的范围内，在哈希表保存的键值对过多或者过少时，需要对哈希表进行相应的扩容或者缩容

	2. rehash步骤

    - 为ht[1]分配空间（扩容操作空间是ht[0]的两倍，缩容则是1/2）
    - 将ht[0]的键值对重新rehash到ht[1]上
    - 释放ht[0]，并将ht[1]重新置为ht[0]
    - 将ht[1]分配一个空白hash表，为下一次rehash做准备

	3. 哈希表的扩容与收缩

    	1. 扩展

             	1. 以下条件任意一个被满足时进行扩展

            1)服务器目前没有在执行 BGSAVE 命令或者BGREWRITEAOF命令,并且哈希表的负 载因子大于等于1。
            2)服务器目前正在执行 BGSAVE 命令或者BGREWRITEAOF命令,并且哈希表的负载 因子大于等于5。

             	2. 哈希表的负载因子公式:

            负载因子 = 哈希表已保存节点数量/哈希表大小

             load_factor = ht[0].used / ht[0].size
             
             	3. 为什么在执行 BGSAVE 命令或者BGREWRITEAOF命令时，负载因子会变大？

            因为redis在执行BGSAVE 命令或者BGREWRITEAOF命令时会创建当前服务器的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以服务器会提高达到扩展条件的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展操作。

            ***可以避免不必要的内存写入操作，最大限度的节省内存***

    2. 收缩

       当哈希表的负载因子小于0.1时，哈希表进行收缩

8. 渐进式rehash

上文提过，rehash分为四个步骤，然而这四个步骤并不是在一次性完成的，在将ht[0]的数据rehash到ht[1]上时，是渐进式的，这个步骤会分多次完成。

1. 渐进式rehash的过程

   - 在rehash开始时，往ht[1]分配对应的空间，在字典中维持一个索引计数器变了rehashidx，并设值为0.

   - 在每次对hash表进行增、删、改、查时，哈希表会顺带将ht[0]中rehashidx索引上的值rehash到ht[1]，当此次rehash完成后，rehashidx+1；

   - 当所有索引上的数据全部rehash完成后，rehashidx重新置为-1，rehash完成。
   - 因为在进行渐进式 rehash 的过程中,字典会同时使用 ht[0]和 ht[1]两个哈希表, 所以在渐进式 rehash 进行期间,字典的删除(delete)、查找(find)、更新(update)等操作 会在两个哈希表上进行。例如,要在字典里面查找一个键的话,程序***会先在ht[0]里面进 行查找,如果没找到的话,就会继续到ht[1] 里面进行查找***,诸如此类。
     另外,在渐进式 rehash 执行期间,***新添加到字典的键值对一律会被保存到ht[1]里面***, 而 ht[0]则不再进行任何添加操作,这一措施保证了ht[0]包含的键值对数量会只减不 增,并随着 rehash 操作的执行而最终变成空表。

2. 为什么要使用渐进式rehash

   如果键值对比较少，可以很快完成，但是如果键值对过多可能会导致服务器在一段时间内停止服务

9. ***重点回顾***

- 字典被广泛用于实现Redis的各种功能,其中包括数据库和哈希键。
- Redis 中的字典使用哈希表作为底层实现,每个字典带有两个哈希表,一个平时使 用,另一个仅在进行rehash时使用。
- 当字典被用作数据库的底层实现,或者哈希键的底层实现时,Redis使用MurmurHash2 算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突,被分配到同一个索引上的多个键值对会连接成一个单向链表。
-  在对哈希表进行扩展或者收缩操作时,程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面,并且这个rehash过程并不是一次性地完成的,而是渐进式地完成的。

### 4、跳跃表

1. 概述

- 跳跃表是一种有序的数据结构，他的每个节点有多个指向其他节点的指针，从而可以达到快速访问其他节点的目的。

  跳跃表平均访问速度为O(logN)，最坏O(N)，并且可以顺序性操作来处理批量节点。

- 大部分情况下跳跃表的效率可以媲美平衡树，实现又比平衡树简单，所以大部分程序采用跳跃表代替平衡树（比如这里的redis）
- Redis只有两个地方用到了跳跃表，一个是***有序集合键***一个是在***集群中用作内部结构***

2. 跳跃表的实现

- Redis 的跳跃表由 redis.h/zskiplistNode 和redis.h/zskiplist 两个结构定 义,其中zskiplistNode 结构用于表示跳跃表节点,而zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。

  ![image-20231012102741226](/Users/leiyu/Library/Application Support/typora-user-images/image-20231012102741226.png)

- zskiplist

  - header:指向跳跃表的表头节点。

  - tail:指向跳跃表的表尾节点。

  - level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算 在内)。

  - length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计 算在内)。

    ![image-20231012113937613](/Users/leiyu/Library/Application Support/typora-user-images/image-20231012113937613.png)

- zskiplistNode

  - 层（level）：图中的L1、L2、L3，分别表示一层、两层、三层，每一层都有两个属性，前进指针和跨度，前进指针指向表尾同层节点，跨度记录了前进指针所到节点和当前节点的距离。（level作用是遍历，一般层数越多遍历越快）
  - 后退(backward)指针：节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用(只指向前一个节点)。
  - 分值(score):各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中, 节点按各自所保存的分值从小到大排列。
  - 成员对象(obj):各个节点中的o1,o2和o3是节点所保存的成员对象，他们指向一个保存着SDS的字符串对象
    - 分值是一个浮点数（double），有可能相等，但是各个节点的成员对象必须唯一，分值相同时节点会按照成员对象在字典中的大小顺序排序。

  ***注意表头节点和其他节点的构造是一样的***:表头节点也有后退指针、分值和成员对象,不 过表头节点的这些属性都不会被用到,所以图中省略了这些部分,只显示了表头节点的各个层。

  - 每次创建一个新的跳跃表节点时。程序都根据幂次定律（power low ，越大的数出现的概率越小）随机生成一个1到32直接的值作为level数组的大小，打个大小就是层的高度

  ![image-20231012111643154](/Users/leiyu/Library/Application Support/typora-user-images/image-20231012111643154.png)

3. 遍历跳跃表

- 迭代程序首先访问跳跃表的第一个节点(表头),然后从第四层的前进指针移动到表
  中的第二个节点。

- 在第二个节点时,程序沿着第二层的前进指针移动到表中的第三个节点。

- 在第三个节点时,程序同样沿着第二层的前进指针移动到表中的第四个节点。

- 当程序再次沿着第四个节点的前进指针移动时,它碰到一个NULL,程序知道这时
  已经到达了跳跃表的表尾,于是结束这次遍历。

  ![image-20231012112348808](/Users/leiyu/Library/Application Support/typora-user-images/image-20231012112348808.png)

  ***注意***：跨度和跳跃表的遍历没有关系，主要是用来判断这个节点在跳跃表里的排位(第几个节点)使用的

4. **重点回顾**

- 跳跃表是有序集合的底层实现之一。
- Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成,其中 zskiplist 用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistNode 则用于表示跳跃表节点。
- 每个跳跃表节点的层高都是1至32之间的随机数。
- 在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的。
- 跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。

### 5、整数集合

1. 整数集合的概念

   - 整数集合(intset)是集合键的底层实现之一,当一个集合只包含整数值元素,并且这 个集合的元素数量不多时,Redis就会使用整数集合作为集合键的底层实现。

2. 整数集合的实现

   - 整数集合(intset)是Redis 用于保存整数值的集合抽象数据结构,它可以保存类型为 int16_t（-32768—32767）、int32_t（-2147483648—2147483647）或者int64_t（-9223 372 036 854 775 808—9223 372 036 854 775 807）的整数值,并且保证集合中不会出现重复元素。

     ![image-20231012143643939](/Users/leiyu/Library/Application Support/typora-user-images/image-20231012143643939.png)

   - contents：是整数数组的底层实现，整数集合中每个元素都是contents数组的一个数组项（item），各个项从小到大排序，并且没有重复项。

   - length：记录了整数集合的长度也就是contents的长度

   - encoding：决定了contents数组里面的整数类型，虽然contens[]被声明为int8_t，但是并不是保存的int8_t类型的整数，主要看encoding属性的值。

     例：下图保存的是encoding属性值为INTSET_ENC_INT16的整数集合

     ![image-20231012144348848](/Users/leiyu/Library/Application Support/typora-user-images/image-20231012144348848.png)

   - 如果往int16_t数组里加入一个2147483648（int_64）的整数，根据整数集合的升级规则会把整个数组升级为int_64类型的

3. 整数集和的升级

   - 每次往集合里添加新元素并且新元素类型比现在的大时需要进行升级

   - 升级时会先分配新的空间，下面以一个int_16类型含有1、2、3三个数的整数集合添加一个int_32的65535为例

     - 原本集合为 3 * 16 = 48位，索引为0、1、2，分别对应0-15位，16-31位，32-47位。
     - 添加元素后应先分配新的空间，把空间整体升级到128位（4*32）
     - 然后根据索引，把3放到索引2（64-95位）的的位置，1和2同理。
     - 最后把65535放到96-127位的位置。
     - 最后把encoding的属性改成int_32，把length属性改为4

   - 每次往整数集合里面添加元素时都可能导致升级，添加元素的时间复杂度为***O(N)***

     因为导致升级的元素不是比现有元素大就是比现有元素小，所以***升级后新元素不是在最开头就是在最末尾***

4. 升级的好处

   - 提升灵活性
     - C语言是静态类型的语言，通常不会把类型不同的值放在同一个数据结构里面。有了升级机制我们可以随意把int_16、int_32或int_64类型的值放入整数集合里而不用担心出现类型错误
   - 节约内存
     - 如果想要一个数组同时可以保存int_16、int_32或int_64三种类型的值只需要将数组置为int_64类型的，但是只有当数组真正出现int_64类型的数值时才会真正用得上，而升级机制很好的在避免了对应的情况节省了内存。

5. 降级

   - ***整数集合不支持降级***，一但将数组升级后，就算删除了对应的元素，数组还是维持当前的类型，不会进行降级。

6. **重点回顾**

   - 整数集合是集合键的底层实现之一。
   - 整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。
   - 升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。
   - 整数集合只支持升级操作,不支持降级操作。

### 6、压缩列表

1. 概述

   - 压缩列表是列表键和哈希键的底层实现**之一**，
   - 当一个列表键只包含少量的列表项，且每个列表项都是小整数或者字符串时，redis就会用压缩列表实现列表键
   - 当一个哈希键只包含少量键值对并且他们的键和值都是小整数或字符串时，redis就会用压缩列表实现列表键

2. 压缩列表的构成

   - ![image-20231013103711171](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013103711171.png)

     ![image-20231013104003339](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013104003339.png)

3. 压缩列表节点的构成

   - 每个列表节点可以保存一个字节数组或者一个整数值

     - 字节数组可以是以下三种长度
       - 长度小于等于63(2-1)字节的字节数组;
       - 长度小于等于16383(2-1)字节的字节数组;
       - 长度小于等于4294967295(2-1)字节的字节数组;
     - 整数值则可以是以下六种长度的其中一种:
       - 4位长,介于0至12之间的无符号整数;
       - 1字节长的有符号整数;
       - 3字节长的有符号整数;
       - int16_t类型整数;
       - int32 t类型整数;
       - int64 t类型整数。

   - ![image-20231013105324325](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013105324325.png)

   - previous_entry_length

     - 记录了前一个节点的长度，当前一个节点的**长度小于254字节时***，previous_entry_length的长度是**1字节**，该字节里保存的就是上一个节点的长度。当前一个节点的**长度大于等于254字节时***，previous_entry_length的长度是**5字节**，其中属性的第一个字节会被设置成为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度。
     - ![image-20231013105918202](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013105918202.png)
     - 该属性常用来**从后往前遍历**时使用，当我们知道一个节点的指针P时，上一个节点的起始地址我们就可以用p - previous_entry_length得到。

   - encoding

     - 该属性可能是一字节、两字节或者五字节，记录了节点的content属性所保存的数据的类型以及长度

       - 属性前两位表示类型编码，后面的表示长度

         "_"表示留空,而b、x等变量则代表实际的二进制数据,为了方便阅读,多
         个字节之间用空格隔开。

         ![image-20231013113902507](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013113902507.png)

   - content

     - 负责保存节点的值，值的类型和长度由encoding决定

       ![image-20231013114449072](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013114449072.png)

4. 连锁更新

   - 如果每个节点的字节都介于250-253之间时，此时添加了一个大于等于254的节点

     - 因为加入的节点大于等于254，他的下一个节点中的previous_entry_length属性就需要从原本的一个节点变为5个节点才能记录上一个节点的长度，当previous_entry_length属性变化后自身节点长度又大于了253，此时会引发下一个节点的更新。

       ![image-20231013120010778](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013120010778.png)

   - 删除操作同样会出现此类情况

     - 假设big大于253字节，small小于253字节，e1到eN都介于250-253之间时
     - ![image-20231013120025041](/Users/leiyu/Library/Application Support/typora-user-images/image-20231013120025041.png)

   - 因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作,而每次空间重 分配的最坏复杂度为O(N),所以连锁更新的最坏复杂度为O(N²)。
   - 连锁更新出现的概率极小，一般不会造成影响。如果只是几个节点的连锁更新也几乎不会有影响。

5. 重点回顾

   - 压缩列表是一种为节约内存而开发的顺序型数据结构。
   - 压缩列表被用作列表键和哈希键的底层实现之一。
   - 压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。
   - 添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,
     但这种操作出现的几率并不高。

### 7、对象

1. 概述
   - reids是键值对数据库，但是并**不是**直接以上文讲的简单动态字符串(SDS)、双端链表、压缩链表、字典、压缩列表、整数集合等直接构成。
   - redis基于这些数据结构构建了一个**对象系统**，这些系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象。每个对象的底层实现都是上文讲到的数据结构之一。
   - **基于引用计数器的内存回收机制**，另外还通过引用计数器实现了对象共享机制（可以在适当的条件下，通过让多个数据库键共享一个对象来节约内存）
   - redis对象带有访问时间记录信息，可以计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的对象会被优先抹除。

2. 对象的类型与编码

   - redis是一个键值对数据库

   - redis使用对象来表示数据库中的键和值

   - 数据库中的键总是字符串类型对象

   - redis中的每个对象都是由redisObject结构表示

     ![image-20231016103821385](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016103821385.png)

     1. 类型，对象的type属性记录了对象的类型，因为键的类型总为字符串类型，所以，我们平时叫某个键值对为xxx键通常以值的类型来命名，比如果字符串键表示值为字符串对象，列表键表示值为列表对象。

        ![image-20231016104043037](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016104043037.png)

        ![image-20231016104104130](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016104104130.png)

     2. 编码和底层实现

        - ptr指针指向对象的底层实现数据结构，而这些数据结构由encoding属性决定，encoding属性可以如下：

          ![image-20231016110052021](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016110052021.png)

          每种对象都至少使用了两种不同的结构编码下图是每种类型的对象可以使用的编码。

          ![image-20231016110158699](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016110158699.png)

          OBJET ENCODIND命令可以查看一个数据库键值对的值对象的编码

          ![image-20231016110320548](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016110320548.png)

          ![image-20231016110327013](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016110327013.png)

        - 为什么使用encoding属性来设定对象的编码类型，而不是直接指定对象的编码类型？

          - 因为通过encoding属性来设置可以提升redis的灵活性和效率。例如在列表对象保含比较少的元素时可以使用压缩列表，当元素较多以后升级为双端链表，这种升级机制可以让redis更灵活，更效率。

3. 字符串对象

   - 字符串对象的编码可以是int、raw和embstr

     1. 如果这个值是整数并且可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里（将void*转换成long）并且将字符串对象的编码设置成int。

     ![image-20231016135328816](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016135328816.png)

     2. 如果保存的是一个字符串，并且字符串的长度大于32字节，那么就会字符串对象就会使用一个SDS来保存这个值，并将编码设置为raw，如果小于32那么就将编码设置为embstr

        - embstr和raw都是使用redisObject和sdshdr结构来表示字符串对象却别在于：

          - raw函数会调用两次内存分配函数来创建redisObject和sdshdr，但是embstr只需要一次，因为在embstr里redisObject和sdshdr是一块连续的空间

            ![image-20231016135708248](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016135708248.png)

          - 所以embstr对比raw在创建和释放时都只会调用一次对应的函数，并且将所有数据都保存在一块连续的内存里面，对比raw能更好的利用缓存带来的优势。

            ![image-20231016135909339](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016135909339.png)

     3. 如果是可以用long double类型表示的浮点数在redis中也是用字符串对象保存的

        - 在保存一个浮点数到字符串对象里时，程序会先将该浮点数转换成字符串再保存。

        - 在对该浮点数进行运算操作时，会现将字符串类型转换成浮点数进行运算，并将得到的答案重新转换成字符串类型并保存。

          ![image-20231016140252817](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016140252817.png)

   - 编码的转换

     - int和embstr类型的编码在满足一定条件时会被转换成raw
       - 当我们对int编码的字符串对象执行了某些命令使得他保存的值不再是整数时会将编码转换成raw。
       - embstr是只读的编码，redis并未对该类型的对象编写任何修改的程序，当我们相对embstr类型的字符串对象进行修改时，程序会现将该对象转换成raw编码类型再进行操作。

   - 字符串命令的实现

     ![image-20231016145247300](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016145247300.png)

4. 列表对象

   - 列表对象的底层实现由压缩列表(ziplist)和双端链表（linkedlist）实现。

   - 当列表元素比较少时使用压缩列表，当列表元素多时使用（转换）双端链表。

     - 注意：双端链表里面的每个节点node都保存了一个字符串对象

       ![image-20231016151211695](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016151211695.png)

       **这里的StringObject就是一个字符串对象，只不过这里简化了**

       这种嵌套字符串对象的表现方式在哈希对象、集合对象和有序集合对象中都会存在，而字符串对象也是唯一一个会被其他四种类型对象嵌套的对象。

   - 编码转换

     1. 满足以下两个条件时会使用ziplist

        - 列表对象保存的所有字符串元素的长度都小于64字节。

        - 元素个数小于512个。

          **注意**以上两个条件的限值是可以在配置文件（关于 list-max-ziplist- value和list-max-ziplist-entries ）中修改的

     2. 当原本使用ziplist的对象中出现了不满足上述条件的情况，就会将原本ziplist重点元素转移到linkedlist中，并修改编码类型使用linkedlist编码。

   - 列表命令的实现

     ![image-20231016155933869](/Users/leiyu/Library/Application Support/typora-user-images/image-20231016155933869.png)

5. 哈希对象

   - 哈希对象的编码可以使ziplist和hashtable

   - 当满足以下两个条件时会使用ziplist编码

     - 哈希对象保存的所有字符串元素的长度都小于64字节。

     - 键值对个数小于512个。

       **注意**以上两个条件的限值是可以在配置文件（关于 hash-max-ziplist- value和hash-max-ziplist-entries ）中修改的

   - ziplist

     - 添加键值对时按照顺序添加到压缩列表的表尾，先添加键后添加值，压缩列表保存哈希对象时总是以键-值-键-值的顺序保存，先添加的在后添加的前面

   - hashtable

     - 当使用hashtable编码时，字典里的每个键和值都是一个字符串对象，里面分别保存了键值对的键和值。

       ![image-20231017105216740](/Users/leiyu/Library/Application Support/typora-user-images/image-20231017105216740.png)

   - 编码的转换

     - 当ziplist在键或者值不满足上面的两个条件之一时会发生编码转换转换成hashtable编码

   - hash命令的实现

     ![image-20231017105346196](/Users/leiyu/Library/Application Support/typora-user-images/image-20231017105346196.png)

6. 集合对象

   - 可以是整数集合编码intset或者字典hashtable编码实现

   - inset

     - 集合对象保存的所有元素都是整数值;

     - 集合对象保存的所有元素数量不超过512个;

       注意：

       1. 满足以上两个条件时使用intset编码，其中一个不满足则使用hashtable编码

       2. 上述条件限值可以在set-max-intset- entries配置中修改。

       3. 当上述条件其中一个不满足时会采用hashtable编码或被转换为hashtable编码。

       ![image-20231017112050895](/Users/leiyu/Library/Application Support/typora-user-images/image-20231017112050895.png)

   - hashtable

     - 用hashtable实现集合对象时，字典里的键都是一个字符串对象，字典里的值都置为空。

       ![image-20231017112059766](/Users/leiyu/Library/Application Support/typora-user-images/image-20231017112059766.png)

   - 集合命令的实现

     ![image-20231017112408368](/Users/leiyu/Library/Application Support/typora-user-images/image-20231017112408368.png)

     ![image-20231017112416373](/Users/leiyu/Library/Application Support/typora-user-images/image-20231017112416373.png)

7. 有序集合对象

   - 有序集合可以是ziplist编码也可以是skiplist编码

     下面以添加如下有序集合为例子

     ![image-20231018143907308](/Users/leiyu/Library/Application Support/typora-user-images/image-20231018143907308.png)

   - ziplist

     - 有序集合保存的元素数量小于128个;

     - 有序集合保存的所有元素成员的长度都小于 64 字节;

       当上述两个条件都满足时会使用ziplist作为有序集合对象的编码

       ![image-20231018143921408](/Users/leiyu/Library/Application Support/typora-user-images/image-20231018143921408.png)

   - skiplist

     - skiplist编码的有序集合对象使用**zset结构**作为底层实现

       一个zset结构同时包含一个skiplist结构和一个字典（dict）结构

     - 为什么要同时使用这两个结构？

       - skiplist中的object属性保存了成员，score属性保存了分值，按照分值排序，在对有序集合进行范围型操作如ZRANK、ZRANGE等是基于跳跃表的API实现的

       - 字典中每个键值对都保存了一个集合元素，可以以O(1)的时间复杂度查到指定的成员的分值

         所以同时使用skiplist结构和一个字典（dict）结构很好的提高了有序集合的效率。同时他们底层通过指针共享相同元素的成员和分值，所以也不会造成任何的内存浪费

         ![image-20231018144536072](/Users/leiyu/Library/Application Support/typora-user-images/image-20231018144536072.png)

         **注意** 为了展示方便,图8-17在字典和跳跃表中重复展示了各个元素的成员和分值,但在实 际中,字典和跳跃表会共享元素的成员和分值,所以并不会造成任何数据重复,也不会因此 而浪费任何内存。

   - 编码的转换

     - 当不满足ziplist的两个条件时会产生编码的转换，其中的限值可以在zset-max-ziplist- entries和zset-max-ziplist-value 配置文件中修改

   - 有序集合命令的实现

     因为有序集合键的值为哈希对象,所以用于有序集合键的所有命令都是针对哈希对象来构建的

     ![image-20231018144827235](/Users/leiyu/Library/Application Support/typora-user-images/image-20231018144827235.png)

8. 类型检查与命令多态

   - Redis分为有两种命令
     - 可以对任意类型键值对执行的命令
       - DEL命令、EXPIRE 命令、RENAME 命令、TYPE 命令、OBJECT 命令等。
     - 只能对指定类型键值对执行的命令
       - SET、GET、APPEND、STRLEN等只能对字符串键执行
       - HDEL、HSET、HGET、HLEN等只能对哈希键执行
       - RPUSH、LPOP、LINSERT、 LLEN等只能对列表键执行
       - SADD、SPOP、SINTER、SCARD等只能对集合键执行
       - ZADD、 ZCARD,、ZRANK, ZSCORE等只能对有序集合键执行
   - 类型的检查
     - 当redis在执行一个只能对特定类型的键执行的命令时，会先检查redisObject结构里面的type类型，如果类型和药执行的命令指定的类型不匹配会向客户端返回一个类型错误。
   - 多态命令的实现
     - Redis除了在执行命令前会进行类型检查，在确认类型正确后，会根据**当前值对象的编码**选择正确的命令来执行。
       - 比如说列表对象有ziplist和linkedlist两种编码，redis在对一个键执行LLEN命令时，会先判断类型是否是列表类型，如果是则再判断值对象使用的编码，如果是ziplist则使用压缩列表的API(ziplistLen函数)来实现命令，如果是linkedlist则使用双端链表的API(listLength函数)来实现。

9. 内存回收

   - C语言没有垃圾回收机制，所以redis在自己的对象中构建了一个引用计数器（reference counting）来实现。程序通过追踪引用计数器这个属性，在合适的时候释放对象进行内存回收。

   - typedef struct redisObject {
         // ..
         // 引用计数 

     ​    int refcount;
     } robj:

   - 对象的引用计数信息会随着对象的使用状态而不断变化:

     - 在创建一个新对象时,引用计数的值会被初始化为1;
     - 当对象被一个新程序使用时,它的引用计数值会被增一;
     - 当对象不再被一个程序使用时,它的引用计数值会被减一;
     - 当对象的引用计数值变为0时,对象所占用的内存会被释放。

10. 对象共享

    - redis会对包含整数值的字符串对象进行共享
      - 当A创建一个值为100的字符串对象的键值对，B也要创建一个值为100的字符串对象时，就会共享这个对象。并且把这个字符串对象的引用计数器变为2。
      - Redis只会共享保存整数值的字符串对象。
        - 因为固然共享对象可以节省很多内存，但是Reids在判断共享对象之前必须确认他们需要的对象完全相同才会进行共享。如果是保存的整数值的字符串对象这里的时间复杂度为O(1)，如果是保存字符串值的复杂对变成了O(n)，如果是包含了多个字符串对象的对象例如列表对象、哈希对象等时间复杂度就会变为O(N²)。
        - 因此,尽管共享更复杂的对象可以节约更多的内存,但受到CPU时间的限制, Redis 只对包含整数值的字符串对象进行共享。

11. 对象的空转时长

    - 除了前面介绍过的type、encoding、ptr 和refcount 四个属性之外, redisObject 结构包含的最后一个属性为1ru属性,该属性记录了对象最后一次被命令程序访问的时间:
      typedef struct redisObject {
           unsigned lru:22;
      } robj;
    - 空转时间就是当前时间减去lru时间得到的
    - **注意** OBJECT IDLETIME 命令的实现是特殊的,这个命令在访问键的值对象时,不会修改值 对象的ru属性。
    - 除了可以被 OBJECT IDLETIME 命令打印出来之外,键的空转时长还有另外一项作用:如果服务器打开了 maxmemory 选项,并且服务器用于回收内存的算法为volatile-lru 或者 allkeys-lru,那么当服务器占用的内存数超过了maxmemory 选项所设置的上限值时 ,空转时长较高的那部分键会优先被服务器释放,从而回收内存。配置文件的 maxmemory 选项和maxmemory-policy 选项的说明介绍了关于这方面的更多信息。

12. 重点回顾

    - Redis 数据库中的每个键值对的键和值都是一个对象。
    - Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象,每种类型的对象 至少都有两种或以上的编码方式,不同的编码可以在不同的使用场景上优化对象的 使用效率。
    - 服务器在执行某些命令之前,会先检查给定键的类型能否执行指定的命令,而检查一个键的类型就是检查键的值对象的类型。
    - Redis 的对象系统带有引用计数实现的内存回收机制,当一个对象不再被使用时,该 对象所占用的内存就会被自动释放。
    - Redis 会共享值为0到9999的字符串对象。
    - 对象会记录自己的最后一次被访问的时间,这个时间可以用于计算对象的空转时间。



## 第二部分-单机数据库的实现

### 1、数据库

1. 服务器中的数据库

   - redis服务器将所有服务器都保存在redisServer结构的db数组中，db数组中每一个都是redisDb结构，一个代表一个数据库。而db数组的个数由dbnum属性来决定。

   - dbnum属性由服务器配置的database选型决定，默认情况下为16.

     struct redisServer {
     		// ...
     		// 一个数组,保存着服务器中的所有数据库 

     ​		redisDb *db;
     ​		// ...

     ​		//服务器的数据库数量
     ​		int dbnum;

     ​		// ...

     }

2. 切换数据库

   - 默认情况下redis客户端的目标数据库为0号数据库，也可以通过select命令来切换数据库。（SELECT 1; 切换到下标为1的数据库）

   - 客户端当前的目标数据库由redisClient结构的db属性记录。

     typedef struct redisClient {

     //......

     // 记录客户端当前正在使用的数据库
     redisDb *db;

     }

     ![image-20231026164628235](/Users/leiyu/Library/Application Support/typora-user-images/image-20231026164628235.png)

   - **谨慎处理多数据库程序**
     - 因为redis没有可以返回客户端目标数据库的命令，所以在切换了数据库以后，长时间可能会出现遗忘的情况，所以在操作数据库之前最好先执行select命令切换到对应的数据库。尤其是执行FLASHDB这种命令的时候。

3. 数据库键空间

   - Redis 是一个键值对(key-value pair)数据库服务器,服务器中的每个数据库都由 一个redis.h/redisDb 结构表示,其中,redisDb 结构的dict字典保存了数据库中的 所有键值对,我们将这个字典称为键空间(key space):
     typedef struct redisDb (
     	// ...
     	// 数据库键空间,保存着数据库中的所有键值对 

     ​	dict *dict;
     ​	// ...
     } redisDb;

   - 我们可以对键空间添加、删除、更新、查找操作

   - 读写时键空间的维护操作

     - 在读取一个键时（读和写都会进行读操作），服务器会根据键是否存在来更新服务器的键空间命中（hit）和不命中（miss）次数。（这两个值可以在 INFO stats 命令的keyspace_hits 属性和 keyspace_misses 属性中查看。）
     - 在读取一个键之后,服务器会更新键的LRU(最后一次使用)时间,这个值可以用于 计算键的闲置时间,使用OBJECT idletime <key> 命令可以查看键 key 的闲置时间。
     - 如果服务器在读取一个键时发现该键已经过期,那么服务器会先删除这个过期键,然后才执行余下的其他操作,本章稍后对过期键的讨论会详细说明这一点。 
     - 如果有客户端使用WATCH 命令监视了某个键,那么服务器在对被监视的键进行修 改之后,会将这个键标记为脏(dirty),从而让事务程序注意到这个键已经被修改 过,第19章会详细说明这一点。
     - 服务器每次修改一个键之后,都会对脏(dirty)键计数器的值增1,这个计数器会触 发服务器的持久化以及复制操作,第10章、第11章和第15章都会说到这一点。
     - 如果服务器开启了数据库通知功能,那么在对键进行修改之后,服务器将按配置发 送相应的数据库通知,本章稍后讨论数据库通知功能的实现时会详细说明这一点。

   - 设置键的生存时间或者过期时间

     - 设置过期时间

       - EXPIRE <key> <ttl> 命令用于将键key的生存时间设置为tt1 秒。
       - PEXPIRE <key> <ttl> 命令用于将键key的生存时间设置为tt1毫秒。
       - EXPIREAT <key> <timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
       - PEXPIREAT <key> <timestamp>命令用于将键key的过期时间设置为timestamp 所指定的毫秒数时间戳。

     - 本质上EXPIRE、PEXPIRE、EXPIREAT 三个命令都是使用PEXPIREAT命令来实现的

       ![image-20231027104250174](/Users/leiyu/Library/Application Support/typora-user-images/image-20231027104250174.png)

   - 保存过期时间

     - redisDb结构的expires字典保存了数据库中所有键的过期时间，称为这个字典的过期字典

       typedef struct redis Db {
       	// ...
       	// 过期字典,保存着键的过期时间
       	dict *expires;
       } redisDb;

     - ![image-20231027104709151](/Users/leiyu/Library/Application Support/typora-user-images/image-20231027104709151.png)

       **注**为了展示方便,图9-12的键空间和过期字典中重复出现了两次 alphabet键对象和 book 键对象。在实际中,**键空间的键和过期字典的键都指向同一个键对象**,所以不会出现任何重复对象,也不会浪费任何空间。

   - 移除过期时间
     - PERSIST可以移除一个键的过期时间，该命令就是PEXPIREAT命令的反操作。

   - 计算并返回剩余时间
     - TTL 命令以秒为单位返回键的剩余生存时间,而PTTL 命令则以毫秒为单位返回键的剩 余生存时间

   - 过期键判定

     - 检查给定键是否存在过期字典
     - 如果存在过期字典，取到过期时间戳和当前时间对比判断键是否过期

   - 过期键删除策略

     - 定时删除:在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的 过期时间来临时,立即执行对键的删除操作。（对内存友好，对CPU不友好）

     - 惰性删除:放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否 过期,如果过期的话,就删除该键;如果没有过期,就返回该键。（对内存不友好，对CPU友好）

     - 定期删除:每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键。至 于要删除多少过期键,以及要检查多少个数据库,则由算法决定。

       在这三种策略中,第一种和第三种为主动删除策略,而第二种则为被动删除策略。

     - 定期删除：
     - 从上面对定时删除和惰性删除的讨论来看,这两种删除方式在单一使用时都有明显的缺陷: 定时删除占用太多CPU时间,影响服务器的响应时间和吞吐量。
       - 惰性删除浪费太多内存,有内存泄漏的危险。 定期删除策略是前两种策略的一种整合和折中:
       - 定期删除策略每隔一段时间执行一次删除过期键操作,并通过限制删除操作执行的 时长和频率来减少删除操作对CPU时间的影响。
         除此之外,通过定期删除过期键,定期删除策略有效地减少了因为过期键而带来的 内存浪费。
     - 定期删除策略的难点是确定删除操作执行的时长和频率:
       - 如果删除操作执行得太频繁,或者执行的时间太长,定期删除策略就会退化成定时 删除策略,以至于将CPU时间过多地消耗在删除过期键上面。
       - 如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策 略一样,出现浪费内存的情况。
       - 因此,如果采用定期删除策略的话,服务器必须根据情况,合理地设置删除操作的执行 时长和执行频率。

4. Redis的过期键删除策略

   Redis采用惰性删除和定期删除两种模式结合的方式。可以很好的在CPU和内存里做一个平衡。

   - 惰性删除策略的实现
     - 在redis对键执行读写命令前，会先调用db.c/expireIfNeeeded函数，如果当前键已经过期则删除，未过期则该函数不做操作。
     - 因为每个键在访问时都有可能先被删除，所以每个命令的实现函数都必须有同时处理键存在或者不存在两种情况。

   - 定期删除策略的实现
     - 过期键的定期删除策略由 redis.c/activeExpireCycle函数实现,每当 Redis 的 服务器周期性操作redis.c/serverCron 函数执行时,activeExpireCycle 函数就会被调用,它在规定的时间内,分多次遍历服务器中的各个数据库,从数据库的expires字 典中***随机检查一部分键***的过期时间,并删除其中的过期键。
     - 函数每次运行时,都从一定数量的数据库中取出一定数量的随机键进行检查,并删 除其中的过期键。
     - 全局变量 current_db 会记录当前activeExpireCycle 函数检查的进度,并 在下一次 activeExpireCycle函数调用时,接着上一次的进度进行处理。比如 说,如果当前activeExpireCycle 函数在遍历10号数据库时返回了,那么下次 activeExpireCycle函数执行时,将从11号数据库开始查找并删除过期键。 
     - 随着 activeExpireCycle函数的不断执行,服务器中的所有数据库都会被检 查一遍,这时函数将 current_db 变量重置为0,然后再次开始新一轮的检查 工作。

5. AOF、RDB和复制功能对过期键的处理

   - 生产RBD文件

     - 执行SAVE或者BGSAVE命令生成RDB文件时，程序会对数据库键过期时间进行检查，已经过期的键不会被保存到RDB文件中。

   - 载入RDB文件

     在启动Redis 服务器时,如果服务器开启了RDB功能,那么服务器将对RDB文件进行 载入:

     - 如果服务器以主服务器模式运行,那么在载入RDB文件时,程序会对文件中保存的键进行检查,未过期的键会被载入到数据库中,而过期键则会被忽略,所以过期键 对载入RDB文件的主服务器不会造成影响。

     - 如果服务器以从服务器模式运行,那么在载入RDB文件时,文件中保存的所有键,
       不论是否过期,都会被载入到数据库中。不过因为***主从服务器在进行数据同步的时候,从服务器的数据库就会被清空***,所以一般来讲,过期键对载入RDB文件的从 服务器也不会造成影响。

       举个例子,如果数据库中包含三个键k1、k2、k3,并且k2已经过期,那么当服务器 启动时:

       - 如果服务器以主服务器模式运行,那么程序只会将k1和k3载入到数据库,k2会 被忽略。
       - 如果服务器以从服务器模式运行,那么k1、k2和k3都会被载入到数据库。

   - AOF文件写入

     **AOF文件保存的是命令**（数据库在加载AOF文件时会执行里面的命令）

     - 当服务器以AOF持久化模式运行时，如果数据库里某个键已经过期，但还未被惰性或者定期删除，AOF文件不会受影响，但是当该键被惰性或者定期删除的时候，程序会往AOF文件里追加一条删除DEL命令，来显示的记录该键已被删除。

   - AOF重写

     - 为什么要进行AOF重写，如果AOF文件时间过长，里面会包含很多创建一个键，然后被过期删除了的命令，这些命令显然已经是没必要的了，所以需要对AOF进行重写。
     - 和生成RDB文件时类似,在执行 AOF 重写的过程中,程序会对数据库中的键进行检 查,已过期的键不会被保存到重写后的AOF 文件中。
     - 举个例子,如果数据库中包含三个键k1、k2、k3,并且k2已经过期,那么在进行重 写工作时,程序只会对k1和k3进行重写,而k2则会被忽略。因此,数据库中包含过期键不会对AOF重写造成影响。

   - 复制

     当程序运行在复制模式下时，从服务器的过期键由主服务器控制。

     - 主服务器在删除一个过期键后会显示的向所有从服务器发送一个删除DEL命令，告知从服务器删除这个过期键。
     - 从服务器在执行客户端发送的读命令时，即使遇到了过期键也不会去删除，而是正常返回，从服务器只有接收到主服务器发送的删除命令的时候才会删除过期键。

6. 数据库通知

   - 键空间通知（key-space notification）
     - 监听某个键所执行的所有命令
     - SUBSCRIBE keyspace@0_ :message 监听键"message"所执行的所有命令

   - 键事件通知（key-event notification）
     - 监听某个命令被哪些键执行了
     - SUBSCRIBE keyevent@0_ :del  监听del命令被哪些键执行了。

   - 服务器配置的 notify-keyspace-events 选项决定了服务器所发送通知的类型:
     - 想让服务器发送所有类型的键空间通知和键事件通知,可以将选项的值设置为AKE。
     - 想让服务器发送所有类型的空间通知,可以将选项的值设置为AK。
     - 想让服务器发送所有类型的键事件通知,可以将选项的值设置为AE。
     - 想让服务器只发送和字符串键有关的键空间通知,可以将选项的值设置为 K$。
     - 想让服务器只发送和列表键有关的键事件通知,可以将选项的值设置为 E1。

7. 重点回顾

   - Redis 服务器的所有数据库都保存在 redisServer.db数组中,而数据库的数量则 由 redisServer.dbnum属性保存。
   - 客户端通过修改目标数据库指针,让它指向redisServer.db 数组中的不同元素 来切换不同的数据库。
   - 数据库主要由dict 和expires 两个字典构成,其中dict字典负责保存键值对, 而expires 字典则负责保存键的过期时间。
   - 因为数据库由字典构成,所以对数据库的操作都是建立在字典操作之上的。
   - 数据库的键总是一个字符串对象,而值则可以是任意一种Redis对象类型,包括字 符串对象、哈希表对象、集合对象、列表对象和有序集合对象,分别对应字符串键、 哈希表键、集合键、列表键和有序集合键
   - expires 字典的键指向数据库中的某个键,而值则记录了数据库键的过期时间,过 期时间是一个以毫秒为单位的UNIX时间戳。
   - Redis 使用惰性删除和定期删除两种策略来删除过期的键:惰性删除策略只在碰到过 期键时才进行删除操作,定期删除策略则每隔一段时间主动查找并删除过期键。
   - 执行 SAVE 命令或者BGSAVE 命令所产生的新RDB文件不会包含已经过期的键。
   - 执行 BGREWRITEAOF 命令所产生的重写AOF文件不会包含已经过期的键。
   - 当一个过期键被删除之后,服务器会追加一条DEL命令到现有AOF文件的末尾,显式地删除过期键。
   - 当主服务器删除一个过期键之后,它会向所有从服务器发送一条DEL命令,显式地删除过期键。
   - 从服务器即使发现过期键也不会自作主张地删除它,而是等待主节点发来DEL命令, 这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。
   - 当 Redis 命令对数据库进行修改之后,服务器会根据配置向客户端发送数据库通知。



### 2、RDB持久化

​		因为redis是内存数据库，所有数据库的键值对数据都是保存在内存而非磁盘里，所以当服务器突然死机的时候或者退出的时候内存里的数据也会消失，所以需要RDB持久化。

​		RDB持久化的时候会生成一个RDB文件在硬盘里，该RDB文件保存了生成RDB文件时的数据库状态,我们可以通过该RDB文件还原当时的数据库状态。

1. RDB文件的的创建和载入

   - SAVE和BGSAVE命令都可以用于生产RDB文件
     - SAVE命令会阻塞服务器的进程，在RDB文件创建完成之前，服务器进程都会阻塞，不能处理任何命令请求。
     - BGSAVE命令会派出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续执行命令请求。
       - 注意：在BFSAVE命令执行期间，SAVE、BGSAVE、BGREWRITEAOF都不能同时执行。(BGREWRITEAOF也是由子进程执行，按理说互不影响，主要是因为两个操作都会存在大量磁盘写入，同时如果一同执行会开辟两个子进程十分影响效率，所以redis在这两个命令其中一个进行时都会拒绝执行另外一个命令。)
   - RDB文件没有用于载入的命令,只有在REDIS服务器启动的时候，如果检测到RDB文件的存在，它就会在动载入RDB文件。
   - 因为AOF文件的更新频率会比RDB文件高，所以如果数据库开启了AOF持久化，数据库会优先使用AOF文件来还原数据库只有在AOF持久化功能处于关闭时才会使用RDB文件来还原数据库。
   - RDB文件的创建和还原分别是由rdbSave和rdbLoad函数执行的。

2. 自动间隔性保存

   - 因为BGSAVE 命令可以在不阻塞服务器进程的情况下执行,所以Redis 允许用户通过设 置服务器配置的save选项,让服务器每隔一段时间自动执行一次BGSAVE 命令。
     用户可以通过save 选项设置多个保存条件,但只要其中任意一个条件被满足,服务器 就会执行 BGSAVE 命令。
     举个例子,如果我们向服务器提供以下配置:
     save 900 1
     save 300 10
     save 60 10000
     那么只要满足以下三个条件中的任意一个,BGSAVE 命令就会被执行:

     - 服务器在900秒之内,对数据库进行了至少1次修改。
     - 服务器在300秒之内,对数据库进行了至少10次修改。
     - 服务器在60秒之内,对数据库进行了至少10000次修改。

   - 设置保存条件

     - REDIS在启动时会根据用户设置的save选项配置，如果用户没有配置，则设置为默认条件：

       save 900 1
       save 300 10
       save 60 10000

     - 然后redis会根据save选项所配置的保存条件，设置服务器状态redisServer结构的saveparams属性saveparams 属性是一个数组,数组中的每个元素都是一个 saveparam 结构,每个 saveparam 结构都保存了一个 save选项设置的保存条件:
       struct saveparam {
       // 秒数
       time_t seconds;
       // 修改数
       int changes;

       }

   - dirty计数器和lastsave属性
     - dirty 计数器记录距离上一次成功执行SAVE 命令或者BGSAVE 命令之后,服务器 对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写入、删除、更 新等操作)。
     - lastsave 属性是一个 UNIX时间戳,记录了服务器上一次成功执行 SAVE 命令或 者 BGSAVE 命令的时间。

   - 检查保存条件是否满足

     - Redis 的服务器周期性操作函数 serverCron 默认每隔100毫秒就会执行一次,该函 数用于对正在运行的服务器进行维护,它的其中一项工作就是检查 save 选项所设置的保存 条件是否已经满足,如果满足的话,就执行 BGSAVE 命令

   - RDB文件结构

     REDIS|db_version|databases|EOF|check_sum

     注：大写宝石常量，小写表示变量和数据（本章所有内容都按照这样表示）

     - RDB 文件的最开头是REDIS部分,这个部分的长度为5字节,保存着"REDIS" 五个 字符。通过这五个字符,程序可以在载入文件时,快速检查所载入的文件是否RDB文件。

       **注意**：因为RDB文件保存的是二进制数据,而不是C字符串,为了简便起见,我们用 "REDIS" 符号代表'R'、'E','D'、'I'、'S' 五个字符,而不是带'\0'结尾符号的C 字符串 'R'、'E'、'D'、'I'、'S'、'\0'。本章介绍的所有内容,以及展示的所有RDB 文件结构图都遵循这一规则。

     - db_version 长度为4字节,它的值是一个字符串表示的整数,这个整数记录了RDB文件的版本号,比如"0006"就代表RDB文件的版本为第六版。本章只介绍第六版RDB 文件的结构。

     - databases 部分包含着零个或任意多个数据库,以及各个数据库中的键值对数据:

       - 如果服务器的数据库状态为空(所有数据库都是空的),那么这个部分也为空,长度 为0字节。
       - 如果服务器的数据库状态为非空(有至少一个数据库非空),那么这个部分也为非空, 根据数据库所保存键值对的数量、类型和内容不同,这个部分的长度也会有所不同。

     - EOF 常量的长度为1字节,这个常量标志着RDB文件正文内容的结束,当读入程序遇 到这个值的时候,它知道所有数据库的所有键值对都已经载入完毕了。

     - check_sum 是一个8字节长的无符号整数,保存着一个校验和,这个校验和是程序通 过对 REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器 在载入RDB文件时,会将载入数据所计算出的校验和与checksum 所记录的校验和进行 对比,以此来检查RDB文件是否有出错或者损坏的情况出现。

       **例**：作为例子,下面展示了一个**databases 部分为空**的RDB文件:文件开头的 "REDIS" 表示这是一个RDB文件,之后的"0006"表示这是第六版的RDB文件,因为 databases 为空,所以版本号之后直接跟着EOF常量,最后的6265312314761917404 是文件的校验和。

       "REDIS"|"0006"|EOF|6265312314761917404

   - database部分

     - 一个RDB文件的database部分可以保存任意多个非空数据库

       REDIS|db_version|databases 0|databases 3|EOF|check_sum

       其中上面就保存了0号数据库和3号数据库的所有键值对。

     - 每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_ pairs三个部分。

       SELECTDB|db number|key_value_pairs

       - SELECTDB常量的长度为1字节，当程序读入到此时，代表下面要读入的是一个数据库了。
       - db number保存着一个数据库号码,根据号码的大小不同,这个部分的长度可以是1字
         节、2字节或者5字节。当程序读入 db number 部分之后,服务器会调用SELECT 命令,根
         据读入的数据库号码进行数据库切换,使得之后读入的键值对可以载入到正确的数据库中。
       - key_value_pairs 部分保存了数据库中的所有键值对数据,如果键值对带有过期时 间,那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过 期时间等条件的不同,key_value_pairs 部分的长度也会有所不同。

   - RDB文件中的数据库结构示例（完整）

     REDIS|db_version|SELECTDB|0|pairs|SELECTDB|3|pairs|EOF|check_sum

   - key_value_pairs部分

     - 每个key_value_pairs都保存了一个或以上数量的键值对，如果键值对带有过期时间则也会保存。

       每个键值对由TYPE|key|value三个结构保存，如果有过期时间则为EXPIRETIME_MS|ms|TYPE|key|value保存，其中TYPE表示键值对的类型，key总是字符串。

   - value的编码

     - 字符串对象

       - 如果TYPE的值为REDIS_RDB_TYPE_STRING,那么value保存的就是一个字符串 对象,字符串对象的编码可以是REDIS_ENCODING_INT 或者 REDIS_ENCODING_RAW。

       - 如果字符串对象保存的是整数（REDIS_ENCODING_INT），保存结构则是ENCODING|integer格式。

       - 如果字符串对象保存的是字符串（REDIS_ENCODING_ROW），根据字符长度，如果长度超过了20，并且开启了RDB文件压缩功能，则会进行压缩。

         - 无压缩字符串保存 len|string

         - 压缩字符串保存  REDIS_RDB_ENC_LZF|compressed_len|origin_len|compressed_string

           LZF压缩算法|压缩后的长度|原始长度|压缩后的字符串。

           RDB文件在读入时会解压缩。

     - 列表对象

       - 如果TYPE 的值为REDIS_RDB_TYPE_LIST,那么value 保存的就是一个REDIS. ENCODING_LINKEDLIST编码的列表对象,RDB文件保存这种对象的结构：
         list_length|item1|item2|......|itemN
       - list_length记录了列表的长度，记录了列表保存了多少个项（item）。
       - 每个item都是一个字符串对象。

     - 集合对象

       - 如果TYPE的值为REDIS_RDB_TYPE_SET,那么value保存的就是一个REDIS. ENCODING_HT编码的集合对象
       - set_size|elem1|elem2|......|elemN
       - 其中set_size记录了集合保存了多少个元素

     - 哈希表对象

       - 如果TYPE的值为REDIS RDB TYPE HASH,那么value保存的就是一个REDIS_ ENCODING_HT 编码的集合对象

       - hash_size|key_value_pair 1|key_value_pair 2|......|key_value_pair N

         - hash_size 记录了哈希表的大小,也即是这个哈希表保存了多少键值对,读入程序 可以通过这个大小知道自己应该读入多少个键值对。
         - 以 key_value_pair开头的部分代表哈希表中的键值对,键值对的键和值都是字
           符串对象,所以程序会以处理字符串对象的方式来保存和读入键值对。

       - 结构可以更消息的表现为下面的形式

         hash_size|key1|value1|key2|value2|......|keyN|valueN

     - 有序集合对象
       - 如果TYPE的值为REDIS_RDB_TYPE_ZSET,那么value保存的就是一个REDIS_ ENCODING_SKIPLIST编码的有序集合对象
       - sorted_set_size|element1|element2|......|elementN
     - INTSET编码的集合
       - 如果 TYPE 的值为REDIS_RDB_TYPE_SET_INTSET,那么 value 保存的就是一个整 数集合对象,RDB文件保存这种对象的方法是,先将整数集合转换为字符串对象,然后将 这个字符串对象保存到 RDB文件里面。
       - 如果程序在读入RDB文件的过程中,碰到由整数集合对象转换成的字符串对象,那么 程序会根据TYPE值的指示,先读入字符串对象,再将这个字符串对象转换成原来的整数集 合对象。
     - ZIPLIST 编码的列表、哈希表或者有序集合
       - 如果TYPE 的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH ZIPLIST 或者 REDIS RDB TYPE ZSET ZIPLIST,那么value保存的就是一个压缩列表对象。
       - RDB保存该对象的方法是，先将压缩列表转换成一个字符串对象。然后将转换得到的字符串对象保存到RDB文件
         - 在读入RDB文件时遇到由压缩列表对象转换成的字符串对象时，程序会根据TYPE的提示，先读入字符串对象，将他转换成原来的压缩列表对象，然后根据TYPE的值，设置压缩列表对象的类型。

3. 重点回顾

   - RDB 文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。
   - SAVE 命令由服务器进程直接执行保存操作,所以该命令会阻塞服务器。
   - BGSAVE 令由子进程执行保存操作,所以该命令不会阻塞服务器。
   - 服务器状态中会保存所有用save 选项设置的保存条件,当任意一个保存条件被满 足时,服务器会自动执行 BGSAVE 命令。
   - RDB 文件是一个经过压缩的二进制文件,由多个部分组成。
   - 对于不同类型的键值对,RDB文件会使用不同的方式来保存它们。

### 3、AOF持久化

RDB 持久化通过保存数据库中的键值对来记录数据库状态，而AOF持久化是通过保存 Redis服务器所执行的写命令来记录数据库状态的。被写入 AOF 文件的所有命令都是以Redis的命令请求协议格式保存的,因为Redis 的 命令请求协议是纯文本格式,所以我们可以直接打开一个AOF文件,观察里面的内容。

1. AOF持久化的实现

   AOF 持久化功能的实现可以分为命令追加(append)、文件写入、文件同步(sync)三 个步骤。

   - 命令追加

     - 当AOF 持久化功能处于打开状态时,服务器在执行完一个写命令之后, 会以协议格式将被执行的命令追加到服务器状态的aof_buf缓冲区的末尾:

   - AOF文件的写入与同步

     - Redis服务器是一个时间循环（loop），这个循环负责接收客户端的命令请求，以及像客户端发送命令回复。也有负责处理时间时间的像serverCron函数这种定时执行的任务。在每一次循环结束以后都会调用FlushAppendOnlyFile函数考虑是否要将aof_buf缓冲区中的命令保存到AOF文件中。

     - flushAppendonlyFile函数的行为由服务器配置的appendfsync 选项的值来决 定,各个不同值产生的行为如图所示。

       ![image-20231114201502325](/Users/leiyu/Library/Application Support/typora-user-images/image-20231114201502325.png)

       如果用户没有指定则默认为everysec。

     - 系统提供了 fsync 和 fdatasync两个同步函数,它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面,从而确保写入数据的安全性。（防止因为突然停机导致的数据丢失）
     - 服务器每执行一个命令都会忘aof_buf中添加一条命令，当flushAppendonlyFile函数被调用时会将aof_buf中的命令保存到aof文件中。

2. AOF文件的载入与数据还原

   - Redis会创建一个伪客户端读取并载入AOF文件。因为Redis命令只能在客户端上下文中执行
     - Redis会创建一个不带网络连接的伪客户端读取AOF文件
     - 循环一条一条的读取并执行AOF中的命令，直到命令全部读取完毕。

3. AOF重写

   - AOF文件会随着执行的命令越来越多导致文件的体积越来越大，所以需要对AOF文件进行重写。
   - AOF重写会读取数据库最新的状态，写入新的命令来实现现在的数据库状态，和原本的AOF命令没有关系。
     - 比如现在数据库有一个list键，执行了四条SADD命令（原本AOF命令中包含四条命令），重写后直接用一条SADD命令直接实现。
   - 生成新的AOF文件后会替换掉原本的AOF文件。

4. AOF后台重写

   - AOF执行重写命令时是创建了一个子进程执行，以免父进程堵塞。
   - AOF重写时，父进程可能会执行新的命令，这时候Redis会将新的命令执行进AOF缓冲区和 **AOF重写缓冲区**，当AOF重写执行完成后将AOF重新缓冲区的命令写入新生成的AOF文件并替换掉旧的AOF文件，这样就不会造成AOF重写后和当前数据库状态不一致的情况。

5. 重点回顾

   - AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
   - AOF 文件中的所有命令都以Redis 命令请求协议的格式保存。
   - 命令请求会先保存到AOF缓冲区里面,之后再定期写入并同步到AOF文件。
   - appendfsync 选项的不同值对AOF 持久化功能的安全性以及Redis 服务器的性能 有很大的影响。
   - 服务器只要载入并重新执行保存在AOF文件中的命令,就可以还原数据库本来的状态。
   - AOF 重写可以产生一个新的AOF文件,这个新的AOF文件和原有的AOF文件所 保存的数据库状态一样,但体积更小。
   - AOF重写是一个有歧义的名字,该功能是通过读取数据库中的键值对来实现的,程 序无须对现有 AOF 文件进行任何读入、分析或者写入操作。
   - 在执行 BGREWRITEAOF 命令时,Redis服务器会维护一个AOF重写缓冲区,该缓冲区会在子进程创建新AOF文件期间,记录服务器执行的所有写命令。当子进程完 成创建新 AOF文件的工作之后,服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾,使得新旧两个AOF文件所保存的数据库状态一致。最后,服务器用新的 AOF 文件替换旧的AOF文件,以此来完成AOF文件重写操作。

### 4、事件

Redis 服务器是一个事件驱动程序,服务器需要处理以下两类事件:

- 文件事件(file event): Redis 服务器通过套接字与客户端(或者其他 Redis 服务器) 进行连接,而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其 他服务器)的通信会产生相应的文件事件,而服务器则通过监听并处理这些事件来 完成一系列网络通信操作。
- 时间事件(time event): Redis 服务器中的一些操作(比如serverCron 函数)需 要在给定的时间点执行,而时间事件就是服务器对这类定时操作的抽象。

1. 文件事件
   - 文件事件处理器使用I/O 多路复用(multiplexing)程序来同时监听多个套接字,并 根据套接字目前执行的任务来为套接字关联不同的事件处理器。
   -  当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关 闭(close)等操作时,与操作相对应的文件事件就会产生,这时文件事件处理器就 会调用套接字之前关联好的事件处理器来处理这些事件。
   
   ![image-20240312103712397](/Users/leiyu/Library/Application Support/typora-user-images/image-20240312103712397.png)
   
   I/O多路复用程序会并发处理套接字，但是会将套接字放在队列里，让后以有序、同步、每次一个套接字的方式发送给文件事件分派器，然后文件事件分派器会根据套接字的类型调用事件处理器（事件处理器就是一个个的函数），等上一个套接字处理完成后，I/O多路复用程序才会往文件事件分派器派送下一个套接字。

2. I/O多路复用程序的实现

   - Redis 的I/O 多路复用程序的所有功能都是通过包装常见的 select、epoll、evport 和 kqueue 这些 I/O 多路复用函数库来实现的,每个I/O 多路复用函数库在 Redis 源码中都 对应一个单独的文件,比如 ae_select.c、ae_epoll.c、ae_kqueue.c,诸如此类。 

   - 因为 Redis 为每个I/O 多路复用函数库都实现了相同的API,所以 I/O 多路复用程序的 底层实现是可以互换的,如图12-3所示。

     ![image-20240312104448839](/Users/leiyu/Library/Application Support/typora-user-images/image-20240312104448839.png)

   - Redis 在 I/O 多路复用程序的实现源码中用 #include 宏定义了相应的规则,程序会在编译时自动选择系统中**性能最高**的I/O 多路复用函数库来作为Redis的I/O 多路复用程序的 底层实现

3. 事件的类型

   - I/O 多路复用程序可以监听多个套接字的ae.h/AE_READABLE 事件和ae.h/AE_ WRITABLE 事件,这两类事件和套接字操作之间的对应关系如下:
   - 当套接字变得可读时(客户端对套接字执行 write操作,或者执行close 操作), 或者有新的可应答(acceptable)套接字出现时(客户端对服务器的监听套接字执行 connect 操作),套接字产生 AE READABLE 事件。
     口当套接字变得可写时(客户端对套接字执行read操作),套接字产生AE_ WRITABLE 事件。
   - I/O 多路复用程序允许服务器同时监听套接字的AE READABLE 事件和AE WRITABLE 事件,如果一个套接字同时产生了这两种事件,那么文件事件分派器会优先处理 AE_ READABLE 事件,等到AE READABLE 事件处理完之后,才处理 AE WRITABLE 事件。
   - 这也就是说,如果一个套接字又可读又可写的话,那么服务器将先读套接字,后写套接字

4. API

   - ae.c/aeCreateFileEvent 函数接受一个套接字描述符、一个事件类型,以及一个 事件处理器作为参数,将给定套接字的给定事件加入到 I/O 多路复用程序的监听范围之内, 并对事件和事件处理器进行关联。
   - ae.c/aeDeleteFileEvent 函数接受一个套接字描述符和一个监听事件类型作为参
     数,让I/O 多路复用程序取消对给定套接字的给定事件的监听,并取消事件和事件处理器之
     间的关联。
   - ae.c/aeGetFileEvents 函数接受一个套接字描述符,返回该套接字正在被监听的 事件类型:
     - 如果套接字没有任何事件被监听,那么函数返回 AE_NONE。
     - 如果套接字的读事件正在被监听,那么函数返回 AE READABLE.
     - 如果套接字的写事件正在被监听,那么函数返回AE_WRITABLE.
     - 如果套接字的读事件和写事件正在被监听,那么函数返回AE_READABLE | AE_ WRITABLE.
   - ae.c/aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数,在给 定的时间内阻塞并等待套接字的给定类型事件产生,当事件成功产生,或者等待超时之后, 函数返回。
   - ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数,并 在指定的时间内,阻塞并等待所有被
   - aeCreateFileEvent 函数设置为监听状态的套接字 产生文件事件,当有至少一个事件产生,或者等待超时后,函数返回。
   - ae.c/aeProcessEvents 函数是文件事件分派器,它先调用aeApiPoll 函数来等 待事件产生,然后遍历所有已产生的事件,并调用相应的事件处理器来处理这些事件。
   - ae.c/aeGetApiName 函数返回I/O 多路复用程序底层所使用的I/O 多路复用函数库 的名称:返回 "epoll"表示底层为epoll函数库,返回"select"表示底层为 select 函数库,诸如此类。

5. 文件事件的处理器

   - Redis 为文件事件编写了多个处理器,这些事件处理器分别用于实现不同的网络通信需 求,比如说:
     - 为了对连接服务器的各个客户端进行应答,服务器要为监听套接字关联连接应答处理器。（常用）
     - 为了接收客户端传来的命令请求,服务器要为客户端套接字关联命令请求处理器。（常用）
     - 为了向客户端返回命令的执行结果,服务器要为客户端套接字关联命令回复处理器。 （常用）
     - 当主服务器和从服务器进行复制操作时,主从服务器都需要关联特别为复制功能编 写的复制处理器。

   1. 连接应答处理器
      - 

